(*==============================================================*)
(* Parameters                                                   *)
(*==============================================================*)

ClearAll[R0, A, w, \[CurlyEpsilon], hFD];

R0 = SetPrecision[1.0, 50];
A  = SetPrecision[1.0*^-4, 50];
w  = SetPrecision[0.02, 50];
\[CurlyEpsilon] = SetPrecision[0.01, 50];

hFD = w/25;

(*==============================================================*)
(* Conformal factor \[CapitalPhi]Safe                                       *)
(*==============================================================*)

ClearAll[\[CapitalPhi]Safe];

\[CapitalPhi]Safe[x_?NumericQ, y_?NumericQ, z_?NumericQ] :=
 Module[{xx = SetPrecision[x, 50],
         yy = SetPrecision[y, 50],
         zz = SetPrecision[z, 50],
         r, \[Phi]},

  r = Max[Sqrt[xx^2 + yy^2 + zz^2], \[CurlyEpsilon]];
  \[Phi] = -A (1 - R0/r) Exp[-((r - R0)^2)/w^2];

  SetPrecision[\[Phi], 50] /. _?Negative :> -10^-30
];

(*==============================================================*)
(* Metric g_{\[Mu]\[Nu]} and inverse                                    *)
(*==============================================================*)

ClearAll[g, gInv];

g[x_?NumericQ, y_?NumericQ, z_?NumericQ] :=
 g[x, y, z] =
  Module[{f = Exp[2 \[CapitalPhi]Safe[x, y, z]]},
    {{-f, 0, 0, 0},
     {0, 1/f, 0, 0},
     {0, 0, 1/f, 0},
     {0, 0, 0, 1/f}}
  ];

gInv[x_?NumericQ, y_?NumericQ, z_?NumericQ] :=
 gInv[x, y, z] = Inverse[g[x, y, z]];

(*==============================================================*)
(* Finite-difference derivative                                 *)
(*==============================================================*)

ClearAll[d\[CapitalPhi]];

d\[CapitalPhi][{x_, y_, z_}, dir_] :=
 Module[{xx = SetPrecision[x, 50], yy = SetPrecision[y, 50],
         zz = SetPrecision[z, 50], \[Delta] = hFD},

  Switch[dir,
   1, ( \[CapitalPhi]Safe[xx + \[Delta], yy, zz] -
        \[CapitalPhi]Safe[xx - \[Delta], yy, zz] )/(2\[Delta]),
   2, ( \[CapitalPhi]Safe[xx, yy + \[Delta], zz] -
        \[CapitalPhi]Safe[xx, yy - \[Delta], zz] )/(2\[Delta]),
   3, ( \[CapitalPhi]Safe[xx, yy, zz + \[Delta]] -
        \[CapitalPhi]Safe[xx, yy, zz - \[Delta]] )/(2\[Delta])
  ]
];

(*==============================================================*)
(* Einstein tensor G_{\[Mu]\[Nu]}                                       *)
(*==============================================================*)

ClearAll[Einstein];

Einstein[x_?NumericQ, y_?NumericQ, z_?NumericQ] :=
 Module[{gradPhi},
  gradPhi = Table[d\[CapitalPhi][{x, y, z}, i], {i, 1, 3}];

  DiagonalMatrix[{
    -2 Total[gradPhi^2],
     2 gradPhi[[1]]^2,
     2 gradPhi[[2]]^2,
     2 gradPhi[[3]]^2
  }]
];

(*==============================================================*)
(* Stress-energy tensor T_{\[Mu]\[Nu]}                                   *)
(*==============================================================*)

ClearAll[T];
T[x_?NumericQ, y_?NumericQ, z_?NumericQ] := Einstein[x, y, z]/(8\[Pi]);

(*==============================================================*)
(* Energy conditions: NEC, WEC, SEC, DEC                        *)
(*==============================================================*)

nullVec = {1, 1, 0, 0};
timeVec = {1, 0, 0, 0};

ClearAll[NEC, WEC];

NEC[x_, y_, z_] := Chop[nullVec . T[x, y, z] . nullVec];
WEC[x_, y_, z_] := Chop[timeVec . T[x, y, z] . timeVec];

(*-----------------------------*
   Strong Energy Condition SEC
 *-----------------------------*)

ClearAll[SEC];

SEC[x_?NumericQ, y_?NumericQ, z_?NumericQ] :=
 Module[{Tval = T[x, y, z], \[Rho], px, py, pz},
  \[Rho]  = -Tval[[1, 1]];
  px =  Tval[[2, 2]];
  py =  Tval[[3, 3]];
  pz =  Tval[[4, 4]];
  Chop[\[Rho] + px + py + pz]
 ];

(*-----------------------------*
   Dominant Energy Condition DEC
 *-----------------------------*)

ClearAll[DEC];

DEC[x_?NumericQ, y_?NumericQ, z_?NumericQ] :=
 Module[{Tval = T[x, y, z], \[Rho], px, py, pz},
  \[Rho]  = -Tval[[1, 1]];
  px =  Tval[[2, 2]];
  py =  Tval[[3, 3]];
  pz =  Tval[[4, 4]];

  If[ \[Rho] >= Abs[px] && \[Rho] >= Abs[py] && \[Rho] >= Abs[pz],
      Chop[\[Rho]],     (* DEC satisfied *)
      Chop[-\[Rho]]     (* DEC violated *)
  ]
 ];

(*==============================================================*)
(* Exotic energy integral                                       *)
(*==============================================================*)

ClearAll[\[Rho], sqrtMinusDet, integrand];

\[Rho][r_?NumericQ] := -T[r, 0, 0][[1, 1]];
sqrtMinusDet[r_] := Exp[-2 \[CapitalPhi]Safe[r, 0, 0]];
integrand[r_?NumericQ] := 4\[Pi] r^2 \[Rho][r] sqrtMinusDet[r];

totalExoticEnergy =
 NIntegrate[
   integrand[r],
   {r, \[CurlyEpsilon], 3 R0},
   WorkingPrecision -> 50,
   AccuracyGoal -> 8,
   PrecisionGoal -> 8,
   Method -> {"GlobalAdaptive", "SymbolicProcessing" -> 0}
 ];

Print["\nâ–º Total exotic (negative) energy =  ", totalExoticEnergy];

(*==============================================================*)
(* Table of NEC, WEC, SEC, DEC                                  *)
(*==============================================================*)

TableForm[
 Table[{r,
        NEC[r, 0, 0],
        WEC[r, 0, 0],
        SEC[r, 0, 0],
        DEC[r, 0, 0]},
       {r, {0.02, 0.05, 0.1, 0.5, 1.0, 2.0}}],
 TableHeadings -> {
   None,
   {"r", "NEC", "WEC", "SEC", "DEC"}
 }
]